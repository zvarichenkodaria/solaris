<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wormhole Entrance Simulation</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: transparent;   /* прозрачный фон */
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
  <!-- убрали status и instruction -->

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );

    camera.position.set(0, 3, 18);

    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true          // ВАЖНО: позволяет прозрачность
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setClearColor(0x000000, 0); // прозрачный фон, а не чёрный
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 2.5;
    controls.maxDistance = 60;
    controls.enablePan = false;

    const geometry = new THREE.PlaneGeometry(2, 2);

    const vertexShader = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = vec4(position, 1.0);
      }
    `;

const fragmentShader = `
  uniform float iTime;
  uniform vec2 iResolution;
  uniform vec3 iCameraPos;
  uniform vec3 iCameraDir;
  uniform vec3 iCameraUp;
  uniform vec3 iCameraRight;

  varying vec2 vUv;

  #define MAX_STEPS 120
  #define WH_RADIUS 1.8
  #define DISK_INNER 2.5
  #define DISK_OUTER 9.0
  #define DISK_HEIGHT 0.10

  float hash(float n) { return fract(sin(n) * 43758.5453123); }

  float noise(vec3 x) {
    vec3 p = floor(x);
    vec3 f = fract(x);
    f = f * f * (3.0 - 2.0 * f);
    float n = p.x + p.y * 57.0 + p.z * 113.0;
    return mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),
                   mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y),
               mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),
                   mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);
  }

  float fbm(vec3 p) {
    float f = 0.0;
    f += 0.5000 * noise(p); p *= 2.02;
    f += 0.2500 * noise(p); p *= 2.03;
    f += 0.1250 * noise(p);
    return f;
  }

  vec4 getDiskColor(vec3 pos) {
    float dist = length(pos);
    if (dist < DISK_INNER || dist > DISK_OUTER || abs(pos.y) > DISK_HEIGHT) return vec4(0.0);

    float density = 1.0 - smoothstep(DISK_INNER, DISK_OUTER, dist);
    float angle = atan(pos.z, pos.x);
    float speed = 3.0 / (dist * dist + 0.1);
    vec3 noiseCoord = vec3(dist * 2.5, angle * 3.0 + iTime * speed, pos.y * 4.0);

    float noiseVal = fbm(noiseCoord);

    vec3 colorHot = vec3(1.2, 1.5, 2.0);
    vec3 colorCold = vec3(0.2, 0.5, 0.8);
    vec3 col = mix(colorCold, colorHot, density * 0.7 + noiseVal * 0.3);

    float alpha = density * noiseVal * 2.0 * smoothstep(DISK_HEIGHT, 0.0, abs(pos.y));
    return vec4(col, alpha);
  }

  void main() {
    vec2 uv = vUv * 2.0 - 1.0;
    uv.x *= iResolution.x / iResolution.y;

    vec3 ro = iCameraPos;
    vec3 rd = normalize(iCameraDir + uv.x * iCameraRight + uv.y * iCameraUp);

    vec3 col = vec3(0.0);
    float glow = 0.0;

    vec3 pos = ro;
    vec3 dir = rd;

    float totalDist = 0.0;
    bool hitThroat = false;

    for(int i = 0; i < MAX_STEPS; i++) {
      float distToCenter = length(pos);

      if(distToCenter < WH_RADIUS) {
        hitThroat = true;
        break;
      }

      vec3 gravity = normalize(-pos) * (0.15 / (distToCenter * distToCenter + 0.01));
      dir = normalize(dir + gravity);

      float stepSize = max(0.05, distToCenter * 0.08);
      if(abs(pos.y) < DISK_HEIGHT * 4.0 && distToCenter < DISK_OUTER + 1.0) stepSize = 0.05;

      pos += dir * stepSize;
      totalDist += stepSize;

      if(distToCenter < DISK_OUTER && distToCenter > DISK_INNER) {
        vec4 diskSample = getDiskColor(pos);
        col += diskSample.rgb * diskSample.a * 0.3 * (1.0 - min(glow, 1.0));
        glow += diskSample.a * 0.3;
      }

      if(totalDist > 80.0) {
        break;
      }
    }

    // лёгкое свечение в районе "горла"
    if (hitThroat) {
      col += vec3(0.5, 0.8, 1.0) * 0.6;
      glow = max(glow, 0.6);
    }

    // гамма‑коррекция
    col = pow(col, vec3(0.4545));

    // прозрачность = накопленному свечению (ограничиваем)
    float alpha = clamp(glow, 0.0, 1.0);
    gl_FragColor = vec4(col, alpha);
  }
`;



    const material = new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms: {
        iTime: { value: 0 },
        iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        iCameraPos: { value: camera.position },
        iCameraDir: { value: new THREE.Vector3() },
        iCameraUp: { value: new THREE.Vector3() },
        iCameraRight: { value: new THREE.Vector3() }
      },
      transparent: true   // шейдер тоже может быть поверх
    });

    const plane = new THREE.Mesh(geometry, material);
    plane.frustumCulled = false;
    scene.add(plane);

    function updateCameraUniforms() {
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      const up = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);
      const right = new THREE.Vector3().crossVectors(dir, camera.up).normalize();
      const realUp = new THREE.Vector3().crossVectors(right, dir).normalize();

      material.uniforms.iCameraPos.value.copy(camera.position);
      material.uniforms.iCameraDir.value.copy(dir);
      material.uniforms.iCameraUp.value.copy(realUp);
      material.uniforms.iCameraRight.value.copy(right);
    }

    function animate(time) {
      requestAnimationFrame(animate);
      const t = time * 0.001;
      material.uniforms.iTime.value = t;

      controls.update();
      updateCameraUniforms();
      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      material.uniforms.iResolution.value.set(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
